#include "CGraph.h"
#include "trace_categories.h"
#include <string>

using namespace CGraph;

// static const char* EXAMPLE_PARAM_KEY = "example-param-key";
static const char* EXAMPLE_IMAGE_TOPIC = "/example/image/topic";
static const int DEFAULT_IMAGE_SIZE = 64;
static const int DEFAULT_MESSAGE_BUF_SIZE = 32;

int sensor_priod = 500;
int sensor_time = 10;

struct ImageMParam : public GMessageParam {
    int frame_id_ = 0;
    char image_buf_[DEFAULT_IMAGE_SIZE] = {0};

    explicit ImageMParam() = default;

    ImageMParam(const ImageMParam& param) : GMessageParam(param) {
        this->frame_id_ = param.frame_id_;
        memcpy(image_buf_, param.image_buf_, DEFAULT_IMAGE_SIZE);
    }

    ImageMParam& operator=(const ImageMParam& param) {
        if (this == &param) {
            return *this;
        }

        this->frame_id_ = param.frame_id_;
        memcpy(image_buf_, param.image_buf_, DEFAULT_IMAGE_SIZE);
        return *this;
    }
};

class SensorNode : public CGraph::GNode {
    public:
      CStatus run() override {
        TRACE_EVENT("rendering", "sensor priod");
        int readout_time = 50;
        int rest_time = sensor_priod - readout_time;

        ImageMParam image;
        image.frame_id_ = cur_index_;
        std::string info = "this is " + std::to_string(cur_index_) + " image";
        memcpy(image.image_buf_, info.c_str(), info.length());
        cur_index_++;

        TRACE_EVENT_BEGIN("rendering", "sensor frame readout");
        TRACE_COUNTER("rendering","sensor frame num" , cur_index_);
        CStatus status;
        CGRAPH_SLEEP_MILLISECOND(readout_time)
        TRACE_EVENT_END("rendering");
        CGRAPH_PUB_MPARAM(ImageMParam, EXAMPLE_IMAGE_TOPIC, image, GMessagePushStrategy::DROP);
        CGRAPH_SLEEP_MILLISECOND(rest_time)
        return status;
      }
    private:
      int cur_index_ = 0;
};

class ConsumerGNode : public GNode {
    public:
        CStatus init() override {
            conn_id_ = CGRAPH_BIND_MESSAGE_TOPIC(ImageMParam, EXAMPLE_IMAGE_TOPIC, DEFAULT_MESSAGE_BUF_SIZE)
            return CStatus();
        }

        CStatus run() override {
            TRACE_EVENT("rendering", perfetto::DynamicString(this->getName() + " run"));
            std::unique_ptr<ImageMParam> image = nullptr;
            auto status = CGRAPH_SUB_MPARAM(ImageMParam, conn_id_, image);
            if (status.isErr()) {
                return status;
            }
            TRACE_EVENT_INSTANT("rendering", "recive sensor frame");

            CGRAPH_SLEEP_MILLISECOND(30)
            CGraph::CGRAPH_ECHO(
                "[%s], exit MyNode1 run function. Sleep for 1 second ... [%d]",
                this->getName().c_str(), image->frame_id_);
            return CStatus();
        }

    private:
        int conn_id_ = 0;
    };

class MyNode1 : public CGraph::GNode {
public:
  CStatus run() override {
    TRACE_EVENT("rendering", perfetto::DynamicString(this->getName() + " run"));
    CStatus status;
    CGraph::CGRAPH_ECHO(
        "[%s], enter MyNode1 run function. Sleep for 1 second ... ",
        this->getName().c_str());
        CGRAPH_SLEEP_MILLISECOND(200)
    return status;
  }
};

class MyNode2 : public CGraph::GNode {
public:
  // 执行过程中，init 和 destroy 方法，单次执行，可选择性实现
  // run 方法可以多次执行，且必须实现
  CStatus init() override {
    CStatus status;
    CGraph::CGRAPH_ECHO("[INIT] [%s], enter MyNode2 init function.",
                        this->getName().c_str());
    return status;
  }

  CStatus run() override {
    TRACE_EVENT("rendering", perfetto::DynamicString(this->getName() + " run"));
    CStatus status;
    CGraph::CGRAPH_ECHO(
        "[%s], enter MyNode2 run function. Sleep for 2 second ... ",
        this->getName().c_str());
        CGRAPH_SLEEP_MILLISECOND(500)
    return status;
  }

  CStatus destroy() override {
    // TRACE_EVENT("rendering", __PRETTY_FUNCTION__, "Instance",
    // this->getName().c_str());
    CStatus status;
    CGraph::CGRAPH_ECHO("[DESTROY] [%s], enter MyNode2 destroy function.",
                        this->getName().c_str());
    return status;
  }
};

std::future<CStatus> async_pipeline_sensor(GPipelinePtr pipeline_sensor) {
    GElementPtr sensornode = nullptr;

    pipeline_sensor->registerGElement<SensorNode>(&sensornode, {}, "Sensor Frame");

    int run_times = sensor_time * 1000 / sensor_priod;

    // 异步执行
    return pipeline_sensor->asyncProcess(run_times);
}

std::future<CStatus> async_pipeline_1(GPipelinePtr pipeline_1) {
    GElementPtr node1A, node1B, node1C = nullptr;

    pipeline_1->registerGElement<ConsumerGNode>(&node1A, {}, "node1A");
    pipeline_1->registerGElement<MyNode1>(&node1B, {node1A}, "node1B");
    // pipeline_1->registerGElement<MyNode2>(&node1C, {node1B}, "node1C");

    // 异步执行
    return pipeline_1->asyncProcess(5);
}


std::future<CStatus>  async_pipeline_2(GPipelinePtr pipeline_2) {
    GElementPtr node2A, node2B, node2C = nullptr;

    pipeline_2->registerGElement<MyNode2>(&node2A, {}, "node2A");
    pipeline_2->registerGElement<MyNode2>(&node2B, {node2A}, "node2B");
    pipeline_2->registerGElement<MyNode2>(&node2C, {node2A}, "node2C");

    return pipeline_2->asyncProcess(3);
}


std::future<CStatus> async_pipeline_3(GPipelinePtr pipeline_3) {
    CStatus status;
    GElementPtr node3A, node3B, node3C, node3D = nullptr;
    GElementPtr region = nullptr;

    node3A = pipeline_3->createGNode<MyNode1>(GNodeInfo({}, "node3A", 1));
    node3B = pipeline_3->createGNode<MyNode2>(GNodeInfo({node3A}, "node3B", 1));
    node3C = pipeline_3->createGNode<MyNode1>(GNodeInfo({node3A}, "node3C", 1));
    node3D = pipeline_3->createGNode<MyNode1>(GNodeInfo({node3B, node3C}, "node3D", 1));

    region = pipeline_3->createGGroup<GRegion>({node3A, node3B, node3C, node3D});

    pipeline_3->registerGElement<GRegion>(&region);
    return pipeline_3->asyncProcess(2);
}


void tutorial_multi_pipeline() {
    GPipelinePtr pipeline_sensor = GPipelineFactory::create();
    GPipelinePtr pipeline_1 = GPipelineFactory::create();
    GPipelinePtr pipeline_2 = GPipelineFactory::create();
    GPipelinePtr pipeline_3 = GPipelineFactory::create();

    /**
     * 设置个别pipeline的内部 thread pool 资源信息，用以减少整体资源占用（可选）
     * 这里主要是为了说明，多个pipeline一起运行的时候，可以通过接口，针对个别pipeline进行调度资源的设置
     */
    UThreadPoolConfig config;
    config.default_thread_size_ = 4;
    config.max_thread_size_ = 4;
    config.monitor_enable_ = false;
    UThreadPool pool(true, config);    // 开辟一个4个线程的线程池，直接 init，并且参数设置为 config

    /**
     * 本例中，pipeline1 和 pipeline2 的并发逻辑相对简单
     * 通过如下接口，将这两个pipeline中的调度资源，修改为同一个线程池。
     * ps：注意，必须在 pipeline init之前，先init传入的线程池
     */
    pipeline_1->setSharedThreadPool(&pool);
    // pipeline_2->setSharedThreadPool(&pool);

    /**
     * 经过上述的设置，pipeline1 和 pipeline2 共享同一个线程池，去调度其中的dag逻辑
     * pipeline3 没有设定，故使用自带的默认线程池完成自己的调度逻辑
     */
    auto resultsensor = async_pipeline_sensor(pipeline_sensor);
    auto result1 = async_pipeline_1(pipeline_1);
    // auto result2 = async_pipeline_2(pipeline_2);
    // auto result3 = async_pipeline_3(pipeline_3);

    resultsensor.wait();
    result1.wait();
    // result2.wait();
    // result3.wait();

    GPipelineFactory::clear();
    CGRAPH_CLEAR_MESSAGES()
}

int main() {
  InitializePerfetto();
  auto tracing_session = StartTracing();

  // Give a custom name for the traced process.
  perfetto::ProcessTrack process_track = perfetto::ProcessTrack::Current();
  perfetto::protos::gen::TrackDescriptor desc = process_track.Serialize();
  desc.mutable_process()->set_process_name("Example");
  perfetto::TrackEvent::SetTrackDescriptor(process_track, desc);

  tutorial_multi_pipeline();

  StopTracing(std::move(tracing_session));
  return 0;
}
